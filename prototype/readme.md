原型模式（Prototype Pattern） 
主要用于需要创建大量相似对象的场景，通过克隆现有对象而不是通过新建来创建新的实例
这种模式特别适合于对象创建过程复杂且成本较高，或者当多个相似对象共享大部分相同的状态时

1. 创建代价高的对象
  当创建一个对象的代价（时间或计算资源）较高时，直接从现有对象克隆而不是每次都重新创建一个新对象，可以显著提高效率
  例子:
  图形编辑器: 在图形编辑软件中，例如用户设计多个相同形状的图形（圆形、矩形等），每个图形对象的创建可能包含复杂的初始化过程。通过原型模式，用户可以复制现有的图形来快速生成新图形
  文件系统中的虚拟文件：比如在虚拟文件系统中，创建新的虚拟文件需要执行复杂的初始化步骤。使用原型模式，可以快速通过克隆现有文件来创建新的文件，而无需重复执行初始化

2. 相似对象的创建
  如果多个对象具有相同或相似的属性，可以通过一个“模板对象”来生成多个实例，而不需要每次都从零开始创建对象。这种场景非常适合使用原型模式来克隆现有对象
  例子:
  游戏中的角色创建: 在角色扮演类游戏中，游戏中的多个角色（例如玩家控制的角色、敌人角色等）可能具有很多相似的属性，如生命值、攻击力、技能等，使用原型模式可以通过克隆模板角色来生成多个类似角色
  UI组件的复制: 在某些应用程序中，多个 UI 组件（如按钮、表格、标签等）可能有相似的布局或样式。原型模式可以用于快速克隆这些组件，以便快速创建多个相似的 UI 元素

3. 复杂对象的构建
  当一个对象的构建过程非常复杂，需要多个步骤才能完成时，使用原型模式可以避免重复的初始化过程。特别是当对象创建过程中涉及到大量的配置或外部资源时，原型模式能够提供更加高效的解决方案
  例子:
  构建报告对象: 例如，报告生成过程可能包括设置标题、段落、表格、图表等多个步骤。如果报告对象的构建过程非常复杂，可以使用原型模式，通过克隆已有的报告模板来快速生成新报告
  数据库连接池: 在一些需要频繁创建数据库连接的应用中，原型模式可以用于克隆已有的连接配置，避免每次都重新建立和配置连接

4. 需要快速复制对象
  在某些系统中，可能需要根据用户的需求创建多个副本或变种的对象。原型模式使得快速复制对象变得简单，而不需要从头开始
  例子：
  文档生成系统：在一些文档管理系统中，用户可能需要从一个模板文档创建多个副本，原型模式可以快速地复制现有文档，而不需要手动重新创建每个文档
  配置文件管理：在分布式系统中，可能需要创建多个类似的配置文件。使用原型模式，可以快速生成相似的配置文件，而不需要重新编写每个文件的内容

5. 对象的共享与复用
  当多个对象共享相同的状态时，原型模式可以有效减少内存的使用和对象的创建时间。通过克隆现有对象并共享它的状态，可以提高性能和资源利用率
  例子：
  共享对象池：在内存中创建和管理多个共享对象时，使用原型模式可以避免重复创建和初始化相同对象。通过对象池管理对象实例，并通过原型模式快速克隆池中的对象
  图形和样式的复用：在图形应用中，如果多个图形使用相同的样式（例如颜色、大小等），可以使用原型模式来复制样式对象，减少样式的重复创建

6. 复杂的对象版本管理
  当对象的状态非常复杂并且需要版本管理时，原型模式非常有用。通过克隆对象，可以保留多个版本的对象副本，避免对象在多个版本之间的状态丢失或混淆
  例子：
  CAD系统中的图形版本：在计算机辅助设计（CAD）软件中，设计师可能在设计过程中需要多次修改图形。原型模式可以帮助设计师保存多个图形版本，并在需要时恢复到某一版本
  文档版本控制：在文档编辑或内容管理系统中，多个版本的文档可能需要被管理和保存，原型模式通过复制文档可以方便地生成不同版本的文档副本

7. 避免重复构建逻辑
  在某些场景中，创建一个对象的过程可能涉及多个复杂的步骤或业务逻辑，通过原型模式，可以避免在多个地方重复构建对象，从而减少错误的发生并简化代码
  例子：
  电子商务系统中的订单创建：订单对象可能涉及多个复杂步骤，如计算价格、选择商品、设置优惠等。使用原型模式，可以通过克隆现有订单模板来减少重复逻辑，提高开发效率
  自动化测试环境设置：在自动化测试中，可能需要多个相似的测试环境配置。通过原型模式，可以复制现有的测试配置，避免每次都重新配置环境


浅拷贝
  定义: 浅拷贝是指在复制对象时，只复制对象的成员变量值。如果对象的成员变量是指针类型，浅拷贝只会复制指针的地址，而不会复制指针所指向的实际数据。即，拷贝后原对象和新对象会共享同一内存地址或指向同一个资源。
  产生的问题: 
    1. 双重释放内存的问题:当原对象和新对象都在析构时试图释放指向同一内存块的指针时，会出现“双重释放内存”的问题。即，内存会被释放多次，这会导致程序崩溃或未定义行为
    2. 资源共享导致意外的修改:由于浅拷贝仅复制了指针的值，即指针指向相同的内存地址，因此修改其中一个对象的数据也会影响另一个对象
    3. 对象的生命周期管理混乱:当多个对象共享同一个内存块时，管理这些对象的生命周期变得非常复杂。每个对象的析构函数都可能试图释放相同的资源，导致程序异常终止

C++ 提倡尽量避免使用裸指针
