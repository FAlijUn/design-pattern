## 单例模式

### 懒汉单例模式
  非线程安全
  getInstance() 方法中的 if (!instance) 检查和实例化是两个独立的操作
  假如两个线程几乎同时访问 getInstance()，它们都通过了 if (!instance) 判断，并且分别创建了两个不同的实例

  懒汉模式(线程安全)
  1. 通过加锁的方式保证线程安全
  2. 但是加锁的方式会影响性能
  3. 且在多线程环境下，每次获取实例都需要加锁，会影响性能
  4. 每次getInstance都需要加锁，即使实例已经创建

  C++11 引入了 std::call_once，它可以确保某段代码只会执行一次，并且具有线程安全性

### 饿汉模式
  饿汉式单例模式是在程序启动时就立即创建实例，不管是否需要使用单例对象
  由于实例在程序启动时就创建了，因此不需要考虑多线程并发访问的问题，天生线程安全
  唯一的缺点是，如果单例对象非常大或者需要很长时间的初始化，而你在程序运行过程中不一定会使用它，这时会浪费资源

### 静态局部变量
  static Singleton instance; 是一个静态局部变量。根据 C++ 标准，静态局部变量的初始化是线程安全的（C++11以后）
  这是因为 C++11 引入了一种称为 静态局部变量初始化的线程安全机制
  具体来说，C++11 对静态局部变量的初始化引入了以下两点保证：
  初始化的原子性：在多线程环境中，只有第一个线程会初始化静态局部变量，其他线程会等待直到初始化完成。这个过程是由编译器和标准库的实现确保的
  初始化的顺序：静态局部变量的初始化在程序的首次调用时才会发生，因此线程安全地完成初始化
  静态局部变量初始化的线程安全性依赖于编译器的实现。在 C++11 标准中，规定：
  如果多个线程同时执行到静态局部变量的初始化语句，只有一个线程会进行初始化操作，其他线程会被阻塞，直到初始化完成
  编译器和运行时系统会确保这一点，通常会使用互斥锁或类似机制来控制对静态局部变量的初始化