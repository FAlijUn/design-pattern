## 单例模式

### 懒汉单例模式
  非线程安全
  getInstance() 方法中的 if (!instance) 检查和实例化是两个独立的操作
  假如两个线程几乎同时访问 getInstance()，它们都通过了 if (!instance) 判断，并且分别创建了两个不同的实例

  懒汉模式(线程安全)
  1. 通过加锁的方式保证线程安全
  2. 但是加锁的方式会影响性能
  3. 且在多线程环境下，每次获取实例都需要加锁，会影响性能
  4. 每次getInstance都需要加锁，即使实例已经创建

  C++11 引入了 std::call_once，它可以确保某段代码只会执行一次，并且具有线程安全性

### 饿汉模式
  饿汉式单例模式是在程序启动时就立即创建实例，不管是否需要使用单例对象
  由于实例在程序启动时就创建了，因此不需要考虑多线程并发访问的问题，天生线程安全
  唯一的缺点是，如果单例对象非常大或者需要很长时间的初始化，而你在程序运行过程中不一定会使用它，这时会浪费资源

### 静态局部变量
  static Singleton instance; 是一个静态局部变量。根据 C++ 标准，静态局部变量的初始化是线程安全的（C++11 以后）